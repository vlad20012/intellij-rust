{
    parserClass='org.rust.lang.core.parser.RustParser'
    parserUtilClass='org.rust.lang.core.parser.RustParserUtil'

    implements='org.rust.lang.core.psi.ext.RsElement'
    extends='org.rust.lang.core.psi.ext.RsElementImpl'

    elementTypeHolderClass='org.rust.lang.core.psi.RsElementTypes'

    elementTypeClass='org.rust.lang.core.psi.RsElementType'
    tokenTypeClass='org.rust.lang.core.psi.RsTokenType'

    psiClassPrefix='Rs'
    psiImplClassSuffix='Impl'
    psiPackage='org.rust.lang.core.psi'
    psiImplPackage='org.rust.lang.core.psi.impl'

    parserImports=[
      'static org.rust.lang.core.parser.RustParserUtil.PathParsingMode.*'
    ]

    tokens = [
        LBRACE      =  '{'
        RBRACE      =  '}'
        LBRACK      =  '['
        RBRACK      =  ']'
        LPAREN      =  '('
        RPAREN      =  ')'
        COLON       =  ':'
        COLONCOLON  =  '::'
        SEMICOLON   =  ';'
        COMMA       =  ','
        EQ          =  '='
        EXCLEQ      =  '!='
        EQEQ        =  '=='
        SHA         =  '#'
        EXCL        =  '!'
        PLUSEQ      =  '+='
        PLUS        =  '+'
        MINUSEQ     =  '-='
        MINUS       =  '-'
        OREQ        =  '|='
        ANDAND      =  '&&'
        ANDEQ       =  '&='
        AND         =  '&'
        OR          =  '|'
        LT          =  '<'
        XOREQ       =  '^='
        XOR         =  '^'
        MULEQ       =  '*='
        MUL         =  '*'
        DIVEQ       =  '/='
        DIV         =  '/'
        REMEQ       =  '%='
        REM         =  '%'
        GT          =  '>'
        DOT         =  '.'
        DOTDOT      =  '..'
        DOTDOTDOT   =  '...'
        DOTDOTEQ    =  '..='
        FAT_ARROW   =  '=>'
        ARROW       =  '->'
        Q           =  '?'
        AT          =  '@'
        UNDERSCORE  =  '_'
        DOLLAR      =  '$'

        // Contextual tokens
        GTGTEQ    = ">>="
        GTGT      = ">>"
        GTEQ      = ">="
        LTLTEQ    = "<<="
        LTLT      = "<<"
        LTEQ      = "<="
        OROR      = "||"
        ANDAND    = "&&"
        UNION     = 'union_kw'
        DEFAULT   = 'default_kw'
        AUTO      = 'auto_kw'
        DYN       = 'dyn_kw'
        ASYNC     = 'async_kw'
        TRY       = 'try_kw'

        MACRO_KW  = 'macro'
        CSELF     = 'Self'
        TYPE_KW   = 'type'

        SHEBANG_LINE = 'shebang_line'
        RESERVED_KEYWORD = 'reserved_keyword'
    ]

    elementType("(Fn|Anon|Lambda|Path)Parameter") = ValueParameter
    elementType("(Fn|Lambda|Path|FnType)Parameters") = ValueParameterList

    extends("(.+Expr|StructLiteral)") = Expr
    elementType(".+BinExpr") = BinaryExpr
    elementType(".+BinOp") = BinaryOp

    extraRoot(".*CodeFragmentElement")=true

    extends("Pat(Wild|Ref|Tup|Slice|Macro|Struct|TupleStruct|Ident|Range|Box|Const|Rest)") = Pat

    generateTokenAccessors=true

    consumeTokenMethod("((?!.*_with_recover).*_recover)|(.*_first)|(.*Expr)") = "consumeTokenFast"
}

// This is the grammar of the Rust language which is used by Grammar Kit
// to generate the parser and the PSI classes. Rule `FooBar` corresponds
// to `RsFooBar` PSI class.
//
// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * macro rules are snake_cased: list_item
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover


File ::= [ SHEBANG_LINE ] InnerAttr* Items
ExpressionCodeFragmentElement ::= Expr?
StatementCodeFragmentElement ::= Stmt?
TypeReferenceCodeFragmentElement ::= TypeReference?
ValuePathCodeFragmentElement ::= ValuePathGenericArgs?
TypePathCodeFragmentElement ::= TypePathGenericArgs?
ReplCodeFragmentElement ::= (Item | Stmt)* Expr?

///////////////////////////////////////////////////////////////////////////////////////////////////
// Attributes
///////////////////////////////////////////////////////////////////////////////////////////////////

InnerAttr ::= '#' '!' '[' AttrUpper {
  implements = [ "org.rust.lang.core.psi.ext.RsAttr" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsInnerAttrStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
OuterAttr ::= '#'     '[' AttrUpper {
  implements = [ "org.rust.lang.core.psi.ext.RsAttr" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private AttrUpper ::= MetaItemWithoutTT ']' |  MetaItemWithTT ']'
private OuterAttr_first ::= '#'

fake MetaItem ::= identifier [ '=' LitExpr | MetaItemArgs ] | CompactTT {
  implements = [ "org.rust.lang.core.psi.ext.RsWeakReferenceElement"
                 "com.intellij.psi.ContributedReferenceHost" ]
  mixin = "org.rust.lang.core.psi.ext.RsMetaItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsMetaItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

// #[test]
//   ~~~~
// #[derive(Debug)]
//   ~~~~~~~~~~~~~
// #![crate_type = "lib"]
//    ~~~~~~~~~~~~~~~~~~
MetaItemWithoutTT ::= identifier [ '=' LitExpr | MetaItemArgs ] { elementType = MetaItem }

// #[some::path]
//   ~~~~~~~~~~
// #[assert_instr(add_a.b)]
//                ~~~~~~~
// #[attr(value = C)]
//        ~~~~~~~~~~
// #[attr(foo::{bar, baz}, qwe())]
//        ~~~~~~~~~~~~~~~~~~~~~~~
MetaItemWithTT ::= CompactTT { elementType = MetaItem }

MetaItemArgs ::= '(' ( [ <<comma_separated_list (LitExpr | MetaItemWithoutTT )>> ] ')' |  MetaItemWithTT ')' ) {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Paths
///////////////////////////////////////////////////////////////////////////////////////////////////

// private PathIdent ::= !("union" identifier | "async" fn) identifier | self | super | 'Self' | crate
private PathIdent ::= <<parsePathIdent>>

fake Path ::= (Path '::' | '::' | TypeQual)? (identifier | self | super | 'Self' | crate) PathTypeArguments? {
  implements = [ "org.rust.lang.core.psi.ext.RsPathReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsPathImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPathStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private Path_first ::= identifier | self | 'Self' | super | '::' | '<' | crate

private PathImpl ::= PathStart PathSegment*

PathStart ::= ('::' | <<checkTypeQualAllowed>> TypeQual)? PathIdent PathTypeArguments? { elementType = Path }
//    <T as Foo>::bar::baz::<i32>
//    ^~~~~~~~~~~^ TypeQual
TypeQual ::= '<' TypeReference [ as TraitRef] '>' '::' {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

left PathSegment ::= '::' PathIdent PathTypeArguments? { elementType = Path }

private PathTypeArguments ::= <<isPathMode 'VALUE'>> ColonTypeArgumentList
                            | <<isPathMode 'TYPE'>> ( TypeArgumentList | PathParameters RetType? ) // Fn(i32) -> i32 sugar

TypeArgumentList ::= TypeArgumentListImpl {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
ColonTypeArgumentList ::= &'::' TypeArgumentListImpl { elementType = TypeArgumentList }

private TypeArgumentListImpl ::= '::'? '<' !'=' <<list_element AnyTypeArgument>>* '>' { pin = 3 }
private AnyTypeArgument ::= AssocTypeBinding | TypeReference | Lifetime | ConstArgument
private ConstArgument ::= (BlockExpr | LitExpr | &('-' LitExpr) UnaryExpr)

AssocTypeBinding ::= identifier (AssocTypeBindingType | AssocTypeBindingBound) {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsAssocTypeBindingMixin"
  stubClass = "org.rust.lang.core.stubs.RsAssocTypeBindingStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private AssocTypeBindingType ::=  '=' TypeReference { pin = 1 }
private AssocTypeBindingBound ::=  ':' TypeBounds { pin = 1 }


// Paths for types:
//    Vec<T>
//    a::b<T,U>::c<V,W>
//    std::Fn(V) -> W
//    std::Fn(V)
TypePathGenericArgs ::= <<pathMode 'TYPE' 'TypeQualsMode.ON' PathImpl>> {
  elementType = Path
  name = "path"
}

TypePathGenericArgsNoTypeQual ::= <<pathMode 'TYPE' 'TypeQualsMode.OFF' PathImpl>> {
  elementType = Path
  name = "path"
}

// Paths without type arguments, for use declarations:
//     a::b::c
PathWithoutTypeArgs ::= <<pathMode 'NO_TYPE_ARGS' 'TypeQualsMode.OFF' PathImpl>> {
  elementType = Path
  name = "path"
}

// Paths for expressions:
//     a::b::<T,U>::c
ValuePathGenericArgs ::= <<pathMode 'VALUE' 'TypeQualsMode.ON' PathImpl>> {
  elementType = Path
  name = "path"
}

ValuePathGenericArgsNoTypeQual ::= <<pathMode 'VALUE' 'TypeQualsMode.OFF' PathImpl>> {
  elementType = Path
  name = "path"
}

// Path semantically constrained to resolve to a trait
TraitRef ::= TypePathGenericArgsNoTypeQual {
  implements = "org.rust.lang.core.psi.ext.RsInferenceContextOwner"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  name = "trait"
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Items
///////////////////////////////////////////////////////////////////////////////////////////////////
Vis ::= crate | pub VisRestriction? {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsVisStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
TupleFieldVis ::= crate !'::' | pub VisRestriction? {
  elementType = Vis
  name = "vis"
}
VisRestriction ::= '(' in? PathWithoutTypeArgs ')' {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

//XXX: don't use contextual keywords in recover, because they remap tokens.
private default_ ::= <<defaultKeyword>>
private union ::= <<unionKeyword>>
private auto ::= <<autoKeyword>>
private dyn ::= <<dynKeyword>>
private async ::= <<asyncKeyword>>
private asyncBlock ::= <<asyncBlockKeyword>>
private try ::= <<tryKeyword>>

private AttrsAndVis ::= OuterAttr* Vis?

// Note: don't forget to add new item element types to [org.rust.lang.core.psi.RS_ITEMS], and to
// `itemKindName` & `itemDefKeyword` in `RsItemElement.kt`
//noinspection BnfUnusedRule
Item ::= AttrsAndVis default_? (Constant
                  | TypeAlias
                  | Function
                  | TraitAlias
                  | TraitItem
                  | ImplItem
                  | ModItem
                  | ModDeclItem
                  | ForeignModItem
                  | StructItem
                  | EnumItem
                  | UseItem
                  | ExternCrateItem
                  | Macro
                  | Macro2
                  | ItemLikeMacroCall) {
  name = "item"
  elementType = ToBeUpped
  hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private Item_with_recover ::= !('}' | <<eof>>) Item {
  pin = 1
  recoverWhile = Item_recover
}
private Item_first ::= '#' | pub | crate | fn | const | extern | unsafe | struct | enum | use | identifier | mod | trait
  | static | TYPE_KW | impl | "union" | "default" | "auto" | "dyn" | "async" | MACRO_KW
private Item_recover ::= !('}' | Item_first )

private Items ::= Item_with_recover*

Lifetime ::= QUOTE_IDENTIFIER {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLifetimeImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsLifetimeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////

// Parameters
fake ValueParameter ::= OuterAttr* Pat? TypeReference? {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsValueParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnParameter ::= OuterAttr* [ Pat ':' ] (VariadicUpper | TypeReference)
upper VariadicUpper ::= '...' ','? { elementType = Variadic }
private FnParameter_with_recover ::= !')' FnParameter (',' | &')') {
  pin = 2
  recoverWhile = FnParameter_recover
}
private FnParameter_recover ::= !(Pat_first | OuterAttr_first | ')' | '...')

LambdaParameter ::= OuterAttr* Pat TypeAscription?
AnonParameter ::= OuterAttr* [ RestrictedPat ':' ] TypeReference
PathParameter ::= OuterAttr* TypeReference !'='

SelfParameter ::= OuterAttr* [ '&' Lifetime? ] mut? self TypeAscription? {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsSelfParameterImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsSelfParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

fake ValueParameterList ::= SelfParameter? ValueParameter* Variadic? {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnParameters          ::= '(' !',' [ SelfParameter (',' | &')') ]
                                   FnParameter_with_recover*
                          ')' { pin = 1 }
LambdaParameters      ::= '|' !',' [ <<comma_separated_list LambdaParameter>> ] '|'

FnTypeParameters      ::= <<variadic_params_impl AnonParameter>>
PathParameters        ::= '::'? '(' [ <<comma_separated_list PathParameter>> ] ')' { pin = 2 }


private meta variadic_params_impl ::= '(' [ <<param>> (',' <<param>>)*  [ ',' '...'? ] ] ')' { pin = 1 }

private RestrictedPat ::= &( [ mut | '&' '&'? ] ( identifier | '_' ) ) Pat

Variadic ::= OuterAttr* [ Pat ':' ] '...' {
    implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
    extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
    stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
    elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeParameterList ::= '<' <<list_element (LifetimeParameter | TypeParameter | ConstParameter)>>* '>' {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private LifetimesParams ::= <<list_element LifetimeParameter>>*

LifetimeParameter ::= OuterAttr* QUOTE_IDENTIFIER LifetimeParamBounds? {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsLifetimeParameterImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsLifetimeParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

LifetimeParamBounds ::= ':' Lifetime ('+' Lifetime)* { pin = 1 }

TypeParameter ::= OuterAttr* identifier TypeParamBounds? DefaultTypeParameterType? {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsTypeDeclarationElement"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsTypeParameterImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsTypeParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private DefaultTypeParameterType ::= '=' TypeReference { pin = 1 }

ConstParameter ::= OuterAttr* const identifier TypeAscription {
  pin = 2
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsConstParameterImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsConstParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private TypeBounds ::= [ Polybound ('+' Polybound)* '+'? ]

TypeParamBounds ::= ':' TypeBounds {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

Polybound ::= '(' PolyboundInner ')' | PolyboundInner {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPolyboundStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private PolyboundInner ::= [ ForLifetimes | '?' ] Bound

WhereClause ::= where <<comma_separated_list WherePred>>? {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

WherePred ::= Lifetime LifetimeParamBounds | ForLifetimes? TypeReference TypeParamBounds {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForLifetimes ::= for '<' LifetimesParams '>' {
  pin = 2
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ExternAbi ::= extern STRING_LITERAL?

RetType ::= '->' TypeReferenceNoImplicitTraitType {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper Function ::= async? const? unsafe? ExternAbi?
                   fn identifier
                   TypeParameterList?
                   FnParameters
                   RetType?
                   WhereClause?
                   (';' | ShallowBlock)
{
  pin = 'identifier'
  name = ""
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsGenericDeclaration"
                 "org.rust.lang.core.psi.ext.RsInnerAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsAbstractable"
                 "org.rust.lang.core.psi.ext.RsUnsafetyOwner"
                 "org.rust.lang.core.psi.ext.RsInferenceContextOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsFunctionImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsFunctionStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

Pat ::= PatWild
      | PatRest
      | PatRef
      | PatTup
      | PatSlice
      | PatMacro
      | PatStruct
      | PatTupleStruct
      | PatIdent
      | (PatConst !('..' | '...' | '..='))
      | PatRange
      | PatBox {
  implements = "org.rust.lang.core.macros.RsExpandedElement"
  name = "pattern"
}

private Pat_first ::= '_' | '..' | '&' | '(' | '[' | Path_first | LitExpr  | box | '-' | ref | mut


PatBox ::= box Pat

// XXX(matklad): it is impossible to distinguish between nullary enum variants
// and identifiers during parsing.
//
//   match x {
//       None => { } // match enum variant
//       Name => { } // bind Name to x
//   }
PatIdent ::= PatBinding [ '@' Pat ]

PatStruct ::= ValuePathGenericArgsNoTypeQual '{' PatField_with_recover* PatRest? '}'
PatTupleStruct   ::= ValuePathGenericArgsNoTypeQual '(' SeqPat ')'

// TODO: actual recover
private Pat_with_recover ::= Pat (',' | &(')' | ']'))
private PatField_with_recover ::= PatField (',' | & '}')

PatConst ::= PathExpr | LitExpr | &('-' LitExpr) UnaryExpr
PatRange ::= PatConst ('..' | '...' | '..=') PatConst { pin = 2 }

PatTup ::= '(' SeqPat ')'
PatSlice ::= '[' SeqPat ']'
// NB: there are `[x, .. , y]`
private SeqPat ::= Pat_with_recover*

PatRef ::= '&' mut? Pat

PatWild ::= '_'
PatRest ::= '..'

PatBinding ::= BindingMode? identifier !'...' !'::' !'..=' !'..' {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsPatBindingImplMixin"
}

PatFieldFull ::= (identifier | INTEGER_LITERAL ) ':' Pat {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsPatFieldFullImplMixin"
}

PatField ::= PatFieldFull | box? PatBinding

BindingMode ::= ref mut? | mut

OrPats ::= '|'? Pat ('|' Pat)*

upper Constant ::= (static mut? | const) (identifier | '_') TypeAscription [ '=' AnyExpr ] ';' {
  pin = 2
  name = ""
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsAbstractable"
                 "org.rust.lang.core.psi.ext.RsInferenceContextOwner"
                 "org.rust.lang.core.macros.RsExpandedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsConstantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsConstantStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper UseItem ::= use UseSpeck ';' {
  pin = "use"
  implements = [ "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsUseItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsUseItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

// You can see the following after the `use`:
//  ::{};
//  {foo, bar};
//  foo::bar as baz;
//  foo::bar::{self, foo};
//  foo::{};
//  ::foo::*;
UseSpeck ::= PathWithoutTypeArgs [ Alias | '::' UseSpeckProjection ]
           | '::'? UseSpeckProjection {
  extends = "org.rust.lang.core.psi.ext.RsUseSpeckImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsUseSpeckStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private UseSpeckProjection ::= '*' | UseGroup
UseGroup ::= '{' UseSpeck_with_recover* '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private UseSpeck_with_recover ::= !'}' UseSpeck (','|&'}') {
  pin = 1
  recoverWhile = UseSpeck_recover
}
private UseSpeck_recover ::= !('}' | '{' | self | super | crate | identifier | '::' | '*' )

Alias ::= as ('_' | identifier) {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedNamedElementImpl<?>"
  mixin = "org.rust.lang.core.psi.ext.RsAliasImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper ExternCrateItem ::= extern crate (identifier | self) Alias? ';' {
  pin = 3
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsExternCrateItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsExternCrateItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper ModItem ::= mod identifier '{' InnerAttr* Items '}' {
  pin = 3
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsMod"
                 "org.rust.lang.core.psi.ext.RsInnerAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsModItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper ModDeclItem ::= mod identifier ';' {
  pin = 'identifier' // make sure `ModDeclItem` goes **after** `ModItem`
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsModDeclItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsModDeclItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper ForeignModItem ::= ExternAbi ForeignModBody {
  implements = [ "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsInnerAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsForeignModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
// Extracted due to a bug in uppers. BACKCOMPAT 2019.3
private ForeignModBody ::= '{' InnerAttr* Items '}' { pin = 1 }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Struct & Enums
///////////////////////////////////////////////////////////////////////////////////////////////////

upper StructItem ::= (struct | union) identifier TypeParameterList?
               ( TupleStructTail | BlockStructTail | UnitStructTail ) {
  pin = 1
  implements = [ "org.rust.lang.core.psi.ext.RsStructOrEnumItemElement"
                 "org.rust.lang.core.psi.ext.RsFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsStructItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsStructItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private TupleStructTail ::= TupleFields WhereClause? ';' { pin = 1 }
private UnitStructTail ::= WhereClause? ';'
private BlockStructTail ::= WhereClause? BlockFields

upper EnumItem ::= enum identifier TypeParameterList? WhereClause? EnumBody {
  pin = "enum"
  implements = "org.rust.lang.core.psi.ext.RsStructOrEnumItemElement"
  mixin = "org.rust.lang.core.psi.ext.RsEnumItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsEnumItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

EnumBody ::= '{' [ <<comma_separated_list EnumVariant>> ] '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

EnumVariant ::= OuterAttr* identifier VariantArgs? {
  pin = 2
  hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsFieldsOwner"
                 "org.rust.lang.core.psi.ext.RsVisible" ]
  mixin = "org.rust.lang.core.psi.ext.RsEnumVariantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsEnumVariantStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private VariantArgs ::= [BlockFields | TupleFields] VariantDiscriminant?

BlockFields ::= '{' (NamedFieldDecl (',' | &'}'))* '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TupleFields ::= '(' (TupleFieldDecl (',' | &')'))* ')' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

VariantDiscriminant ::= '=' AnyExpr {
  pin = 1
  implements = "org.rust.lang.core.psi.ext.RsInferenceContextOwner"
}

NamedFieldDecl ::= AttrsAndVis identifier TypeAscription {
  pin = 2
  hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
  implements = [ "org.rust.lang.core.psi.ext.RsFieldDecl"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsQualifiedNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsNamedFieldDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsNamedFieldDeclStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  recoverWhile = Field_recover
}
private Field_recover ::= !('}' | ',')

TupleFieldDecl ::= OuterAttr* TupleFieldVis? TypeReference {
  implements = [ "org.rust.lang.core.psi.ext.RsFieldDecl" ]
  mixin = "org.rust.lang.core.psi.ext.RsTupleFieldDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
  recoverWhile = TupleField_recover
}
private TupleField_recover ::= !(')' | ',')


///////////////////////////////////////////////////////////////////////////////////////////////////
// Trait & Impl
///////////////////////////////////////////////////////////////////////////////////////////////////

upper TraitItem ::= unsafe? auto? trait identifier TypeParameterList? TypeParamBounds? WhereClause? Members {
  pin = "trait"
  name = ""
  implements = [ "org.rust.lang.core.psi.ext.RsTraitOrImpl"
                 "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsUnsafetyOwner"
                 "org.rust.lang.core.psi.ext.RsTypeDeclarationElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsTraitItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsTraitItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper ImplItem ::= unsafe? impl TypeParameterList? ( TraitImpl | InherentImpl ) WhereClause? Members {
  pin = "impl"
  name = ""
  implements = [ "org.rust.lang.core.psi.ext.RsTraitOrImpl"
                 "org.rust.lang.core.psi.ext.RsUnsafetyOwner"
                 "org.rust.lang.core.psi.ext.RsInnerAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsTypeDeclarationElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsImplItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsImplItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private TraitImpl ::= '!'? TraitRef for ('..' | TypeReference)  { pin = 3 }
private InherentImpl ::= TypeReference !for

Members ::= '{' InnerAttr* Items '}' {
  pin = 1
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TraitAliasBounds ::= TypeBounds {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

upper TraitAlias ::= trait identifier TypeParameterList? '=' TraitAliasBounds? WhereClause? ';' {
  pin = 4
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsGenericDeclaration"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 /* "org.rust.lang.core.psi.ext.RsTypeDeclarationElement" */ ]
  mixin = "org.rust.lang.core.psi.ext.RsTraitAliasImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsTraitAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////

private TypeAscription ::= ':' TypeReference { pin = 1 }

private TypeReferenceInner ::= ArrayType
                               | RefLikeType
                               | FnPointerType
                               // External rule to find the difference between `(T)` and `(T,)`
                               | <<tupleOrParenType TypeReferenceInner TupleType_upper>>
                               | ExplicitTraitType
                               | TrivialBaseType
                               // External rule to find the difference between `T` and `T+T`
                               | <<baseOrTraitType TypePathGenericArgs ImplicitTraitType TraitType_upper>>
                               | MacroType
                               | ForInType // FIXME O(2^n) for types like `for<'a> A<for<'b> B<for<'c> C<...>>>`

private TypeReferenceNoImplicitTraitTypeInner ::= ArrayType
                               | RefLikeType
                               | FnPointerType
                               // External rule to find the difference between `(T)` and `(T,)`
                               | <<tupleOrParenType TypeReferenceInner TupleType_upper>>
                               | ExplicitTraitType
                               | MacroType
                               | BaseType
                               | ForInType // FIXME O(2^n) for types like `for<'a> A<for<'b> B<for<'c> C<...>>>`

private ScalarTypeReferenceInner ::= ArrayType
                                   | RefLikeType
                                   | FnPointerType
                                   | <<tupleOrParenType ScalarTypeReferenceInner TupleType_upper>>
                                   | MacroType
                                   | BaseType
                                   | ForInType

TypeReference ::= TypeReferenceInner {
  implements = "org.rust.lang.core.macros.RsExpandedElement"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  mixin = "org.rust.lang.core.psi.ext.RsTypeReferenceImplMixin"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  name = "type"
}

TypeReferenceNoImplicitTraitType ::= TypeReferenceNoImplicitTraitTypeInner {
  elementType = TypeReference
  name = "type"
}

ScalarTypeReference ::= ScalarTypeReferenceInner {
  elementType = TypeReference
  name = "type"
}

ArrayType ::= '[' TypeReference [';' AnyExpr] ']' {
  pin = 1
  implements = [ "org.rust.lang.core.psi.ext.RsTypeElement" "org.rust.lang.core.psi.ext.RsInferenceContextOwner" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsArrayTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

RefLikeType ::= ( '&' Lifetime? mut? | '*' [ const | mut ] ) TypeReference {
  pin = 1
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsRefLikeTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnPointerType ::= [ unsafe? ExternAbi? ] fn FnTypeParameters RetType? {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

MacroType ::= ExprLikeMacroCall {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TupleType ::= '(' [ <<comma_separated_list TypeReference>> ] ')' {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private TupleType_upper ::= (',' TypeReference)* ','? ')'

Bound ::= Lifetime | TraitRef {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForInType ::= ForLifetimes (FnPointerType | TraitRef) {
  pin = 1
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

BaseType ::= TrivialBaseTypeInner | TypePathGenericArgs {
  implements = [ "org.rust.lang.core.psi.ext.RsTypeElement"
                 "org.rust.lang.core.psi.ext.RsInferenceContextOwner" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsBaseTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TrivialBaseType ::= TrivialBaseTypeInner { elementType = BaseType }
private TrivialBaseTypeInner ::= '(' ')' | '_' | '!'

// `impl Trait` or `dyn Trait` or `Trait+'a`
fake TraitType ::= ExplicitTraitTypeInner | ImplicitTraitTypeInner {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsTraitTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ExplicitTraitType ::= ExplicitTraitTypeInner { elementType = TraitType }
private ExplicitTraitTypeInner ::= (impl | dyn) Polybound ('+' Polybound)* { pin = 1 }

ImplicitTraitType ::= ImplicitTraitTypeInner { elementType = TraitType }
private ImplicitTraitTypeInner ::= Polybound ('+' Polybound)+

private TraitType_upper ::= ('+' Polybound)+

upper TypeAlias ::= TYPE_KW identifier
              [ TypeParameterList WhereClause? | WhereClause | TypeParamBounds ]
              [ '=' TypeReference ] ';' {
  pin = 'identifier'
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsGenericDeclaration"
                 "org.rust.lang.core.psi.ext.RsAbstractable"
                 "org.rust.lang.core.psi.ext.RsTypeDeclarationElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsTypeAliasImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsTypeAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/reference.html#operator-precedence
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
//
// Rust expression grammar allows or forbids struct literals depending on context.
// There are `no_struct_lit_expr` and `any_expr` productions for this two cases.
// `expr` production is an implementation detail. It passes the context information to the child expressions.
Expr ::= RetExpr
       | YieldExpr
       | LambdaExpr
       | AssignBinExpr

       | WhileExpr
       | IfExpr
       | ForExpr
       | LoopExpr
       | MatchExpr
       | BlockExpr

       | ContExpr
       | BreakExpr
       | FullRangeExpr
       | OpenRangeExpr
       | BoolOrBinExpr
       | BoolAndBinExpr
       | CompBinExpr
       | RelCompBinExpr
       | BitOrBinExpr
       | BitXorBinExpr
       | BitAndBinExpr
       | BitShiftBinExpr
       | AddBinExpr
       | MulBinExpr
       | CastExpr
       | UnaryExpr
       | TryExpr
       | AtomExpr {
  implements = "org.rust.lang.core.macros.RsExpandedElement"
  mixin = "org.rust.lang.core.psi.ext.RsExprMixin"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
}

private Expr_first ::= return | '|' | Path_first | '{' | '[' | '(' | '..' | '...' | '..=' | true | false | box | QUOTE_IDENTIFIER
  | '-' | '*' | '!' | '&' | static | move | LitExpr | while | if | for | continue | break  | loop | match | unsafe
  | yield | "async" | "try"

// https://github.com/rust-lang/rfcs/blob/master/text/0092-struct-grammar.md
NoStructLitExpr ::= <<exprMode 'StructLiteralsMode.OFF' 'StmtMode.OFF' Expr>> {
  elementType = Expr
  name = "expr"
}
AnyExpr ::= <<exprMode 'StructLiteralsMode.ON' 'StmtMode.OFF' Expr>> {
  elementType = Expr
  name = "expr"
}
StmtModeExpr ::= <<exprMode 'StructLiteralsMode.ON' 'StmtMode.ON' Expr>> {
  elementType = Expr
  name = "expr"
}
StmtModeExprOff ::= <<stmtMode 'StmtMode.OFF' Expr>> {
  elementType = Expr
  name = "expr"
}

BlockExpr ::= OuterAttr* [ (unsafe | asyncBlock move? | try) &'{' ] LabelDecl? SimpleBlock {
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}


private AtomExpr ::= LitExpr
                    | MacroExpr
                    | StructLiteral
                    | DotExpr
                    | IndexExpr
                    | PathExpr !'('
                    | CallExpr
                    | ArrayExpr
                    | UnitExpr
                    | TupleOrParenExpr

fake BinaryExpr ::= Expr BinaryOp Expr {
  methods=[
    left="/Expr[0]"
    right="/Expr[1]"
  ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

fake BinaryOp ::= '>>=' | '<<=' | '|=' | '^=' | '&=' | '=' | '+=' | '-=' | '*=' | '/=' | '%='
                | '==' | '!='
                | '<' | '>' | '<=' | '>='
                | '<<' | '>>'
                | '+' | '-' | '*' | '/' | '%'
                | '||' | '&&' | '|' | '&' | '^' {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsBinaryOpImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsBinaryOpStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

AssignBinExpr ::= Expr AssignBinOp Expr    { rightAssociative = true }
AssignBinOp ::= gtgteq | ltlteq | '|=' | '^=' | '&=' | '=' | '+=' | '-=' | '*=' | '/=' | '%=' { name = "operator" }

CompBinExpr      ::= Expr !<<isCompleteBlockExpr>> CompBinOp StmtModeExprOff
RelCompBinExpr   ::= Expr !<<isCompleteBlockExpr>> RelCompBinOp StmtModeExprOff
BitShiftBinExpr  ::= Expr !<<isCompleteBlockExpr>> BitShiftBinOp StmtModeExprOff
AddBinExpr       ::= Expr !<<isCompleteBlockExpr>> AddBinOp StmtModeExprOff
MulBinExpr       ::= Expr !<<isCompleteBlockExpr>> MulBinOp StmtModeExprOff

CompBinOp        ::= '==' | '!=' { name = "operator" }
RelCompBinOp     ::= lteq | gteq | !ltlt '<' | !gtgt '>' { name = "operator" }
BitShiftBinOp    ::= ltlt | gtgt { name = "operator" }
AddBinOp         ::= '+' | '-' { name = "operator" }
MulBinOp         ::= '*' | '/' | '%' { name = "operator" }

// <expr> | <expr> has higher priority than <expr> || <expr>
BoolOrBinExpr    ::= Expr !<<isCompleteBlockExpr>> BoolOrBinOp StmtModeExprOff
BoolAndBinExpr   ::= Expr !<<isCompleteBlockExpr>> BoolAndBinOp StmtModeExprOff
BitOrBinExpr     ::= Expr !(<<isCompleteBlockExpr>> | oror) BitOrBinOp StmtModeExprOff
BitAndBinExpr    ::= Expr !(<<isCompleteBlockExpr>> | andand) BitAndBinOp StmtModeExprOff
BitXorBinExpr    ::= Expr !<<isCompleteBlockExpr>> BitXorBinOp StmtModeExprOff

BoolOrBinOp      ::= oror { name = "operator" }
BoolAndBinOp     ::= andand { name = "operator" }
BitOrBinOp       ::= '|' { name = "operator" }
BitAndBinOp      ::= '&' { name = "operator" }
BitXorBinOp      ::= '^' { name = "operator" }

CastExpr ::= Expr (as | ':')  ScalarTypeReference {
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TryExpr ::= Expr '?' {
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

UnaryExpr ::= OuterAttr* (box | '-' | '*' | '!' | '&' mut?) Expr {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

LambdaExpr ::= OuterAttr* [asyncBlock | static] move? LambdaParameters RetType? AnyExpr {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

StructLiteral ::= <<checkStructAllowed>> OuterAttr* ValuePathGenericArgsNoTypeQual StructLiteralBody {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

StructLiteralBody ::= '{' StructLiteralField_with_recover* ('..'  AnyExpr)? '}' { pin = 1 }

StructLiteralField ::= OuterAttr* (identifier | INTEGER_LITERAL) StructLiteralFieldSuffix? {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsStructLiteralFieldImplMixin"
}

private StructLiteralFieldSuffix ::= ':' AnyExpr { pin = 1 }

private StructLiteralField_with_recover ::= StructLiteralField (',' | &'}') {
  pin = 1
  recoverWhile = StructLiteralField_recover
}

private StructLiteralField_recover ::= !(identifier | INTEGER_LITERAL | ',' | '}' | '..' | '#')

PathExpr ::= OuterAttr* ValuePathGenericArgs {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

WhileExpr ::= OuterAttr* LabelDecl? while Condition SimpleBlock {
  pin = 'while'
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsLooplikeExpr" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
Condition ::= [ let OrPats '=' ] NoStructLitExpr

LoopExpr ::= OuterAttr* LabelDecl? loop SimpleBlock {
  pin = 'loop'
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsLooplikeExpr"]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ContExpr ::= OuterAttr* continue Label? {
  implements = [ "org.rust.lang.core.psi.ext.RsLabelReferenceOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsContMixin"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

BreakExpr ::= OuterAttr* break Label? AnyExpr? {
  implements = [ "org.rust.lang.core.psi.ext.RsLabelReferenceOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsBreakMixin"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForExpr ::= OuterAttr* LabelDecl? for Pat in NoStructLitExpr SimpleBlock {
  pin = 'for'
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsLooplikeExpr" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

LabelDecl ::= QUOTE_IDENTIFIER ':' {
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsLabelDeclImplMixin"
}
Label ::= QUOTE_IDENTIFIER {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLabelImplMixin"
}

MatchExpr ::= OuterAttr* match NoStructLitExpr MatchBody {
  pin = 'match'
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
MatchBody ::= '{' MatchArm* '}' { pin = 1 }
MatchArm ::= OuterAttr* OrPats MatchArmGuard? '=>' StmtModeExpr (',' | (&'}' | <<isBlock>>)) {
  pin = 2
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  recoverWhile = MatchArm_recover
}
private MatchArm_recover ::= !(Pat_first | OuterAttr_first | '}' | '|')
MatchArmGuard ::= if AnyExpr

IfExpr ::= OuterAttr* if Condition SimpleBlock ElseBranch? {
  pin = 'if'
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
ElseBranch ::= else ( IfExpr | SimpleBlock )

RetExpr ::= OuterAttr* return Expr? {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

UnitExpr ::= OuterAttr* '(' ')' {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

fake TupleExpr ::= '(' AnyExpr+ ')' {
  pin = 2
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
fake ParenExpr ::= '(' AnyExpr ')' {
  pin = 2
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TupleOrParenExpr ::= OuterAttr* '(' AnyExpr (TupleExprUpper | ')') {
  pin = 2
  elementType = ParenExpr
}
upper TupleExprUpper ::= ',' [ AnyExpr (',' AnyExpr)* ','? ] ')' { pin = 1 elementType = TupleExpr }

ArrayExpr ::= OuterAttr* '[' ArrayInitializer ']' {
  pin = 2
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private ArrayInitializer ::= [ AnyExpr ( ';' AnyExpr | (',' AnyExpr)* ','? ) ]

fake RangeExpr ::= Expr? ('..' | '...' | '..=') Expr? {
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FullRangeExpr ::= Expr ( ('..' | '...' | '..=')  (<<checkBraceAllowed>> Expr)?) { elementType = RangeExpr }
OpenRangeExpr ::=      ( ('..' | '...' | '..=')  (<<checkBraceAllowed>> Expr)?) { elementType = RangeExpr }

IndexExpr ::= Expr IndexArg {
 elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

CallExpr ::= Expr !<<isCompleteBlockExpr>> ValueArgumentList {
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
ValueArgumentList ::= '(' <<comma_separated_list AnyExpr>>? ')' { pin = 1 }

DotExpr ::= Expr '.'  MethodOrField {
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private MethodOrField ::= () (MethodCall | FieldLookup) { pin = 1}

FieldLookup ::= identifier | INTEGER_LITERAL {
  implements = [ "org.rust.lang.core.psi.ext.RsMethodOrField" ]
  mixin = "org.rust.lang.core.psi.ext.RsFieldLookupImplMixin"
}

MethodCall ::= identifier ColonTypeArgumentList? ValueArgumentList {
  implements = [ "org.rust.lang.core.psi.ext.RsMethodOrField" ]
  mixin = "org.rust.lang.core.psi.ext.RsMethodCallImplMixin"
}

LitExpr ::= OuterAttr*
  (STRING_LITERAL | BYTE_STRING_LITERAL
  | RAW_STRING_LITERAL | RAW_BYTE_STRING_LITERAL
  | CHAR_LITERAL | BYTE_LITERAL
  | INTEGER_LITERAL | FLOAT_LITERAL
  | BOOL_LITERAL) {
 elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
 implements = [ "com.intellij.psi.PsiLanguageInjectionHost"
                "com.intellij.psi.ContributedReferenceHost"
                "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
 mixin = "org.rust.lang.core.psi.ext.RsLitExprMixin"
}

YieldExpr ::= OuterAttr* yield Expr? {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////////////////////////

upper Macro ::= "macro_rules" '!' identifier ShallowMacroBody <<macroSemicolon>> {
  pin = 2
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.macros.RsExpandedElement"
                 "org.rust.lang.core.psi.ext.RsModificationTrackerOwner" ]
  extends = "org.rust.lang.core.psi.ext.RsMacroImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsMacroStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

BlockElementMacro ::= AttrsAndVis Macro {
  name = "macro"
  elementType = ToBeUpped
}

MacroBody ::= <<any_braces (MacroCase ';'?)*>> {
  elementTypeFactory = "org.rust.lang.core.psi.LazyElementsKt.factory"
  extraRoot = true
}
private ShallowMacroBody ::= <<parseMacroBodyLazy>>

MacroCase ::= MacroPattern '=>' MacroExpansion { pin = 1 }

MacroPattern ::= <<any_braces MacroPatternContents >>
MacroPatternContents ::=
  (MacroPattern | MacroBinding | MacroBindingGroup | <<unpairedToken>>)*

MacroBinding ::= '$' MetaVarIdentifier ':' identifier {
  pin = 2
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsMacroBindingImplMixin"
}
MetaVarIdentifier ::= <<macroIdentifier>>
MacroBindingGroup ::= '$' '(' MacroPatternContents ')' MacroBindingGroupSeparator? ('*' | '+' | '?') { pin = 2 }
MacroBindingGroupSeparator ::= <<macroBindingGroupSeparatorToken>>

MacroExpansion ::= <<any_braces MacroExpansionContents>>

MacroExpansionContents ::=
  (MacroExpansion | MacroReference | MacroExpansionReferenceGroup | <<unpairedToken>>)*

MacroReference ::= '$' MetaVarIdentifier {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsMacroReferenceImplMixin"
}
MacroExpansionReferenceGroup ::= '$' '(' MacroExpansionContents ')' MacroExpansionGroupSeparator? ('*' | '+' | '?') { pin = 2 }
MacroExpansionGroupSeparator ::= <<macroBindingGroupSeparatorToken>>

upper Macro2 ::= MACRO_KW identifier ( Macro2FunctionLikeBody | Macro2MatchLikeBody ) {
  pin = 1
  implements = [ "org.rust.lang.core.psi.ext.RsNameIdentifierOwner"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsQualifiedNamedElement" ]
  extends = "org.rust.lang.core.psi.ext.RsMacro2ImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsMacro2Stub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private Macro2FunctionLikeBody ::= '(' MacroPatternContents ')' '{' MacroExpansionContents '}'
private Macro2MatchLikeBody ::= '{' (MacroCase ','?)* '}'

fake MacroCall ::= AttrsAndVis PathWithoutTypeArgs '!' identifier? (
    MacroArgument | ExprMacroArgument | FormatMacroArgument | AssertMacroArgument |
      VecMacroArgument | LogMacroArgument | IncludeMacroArgument | ConcatMacroArgument | EnvMacroArgument
    ) ';'? {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.macros.RsExpandedElement"
                 "org.rust.lang.core.psi.ext.RsModificationTrackerOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsMacroCallImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsMacroCallStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

// Parses top-level macro calls with semicolon like `foo!();`
upper ItemLikeMacroCall ::= <<parseMacroCall 'MacroCallParsingMode.ITEM'>> {
  elementType = MacroCall
  name = ""
}

// Parses macro calls with semicolon like `foo!();`. Unlike `ItemLikeMacroCall` rule, it does not recover on a missing semicolon.
// This rule is required to distinguish statements from expressions like `foo!() + 1` inside blocks.
BlockElementMacroCall ::= <<parseMacroCall 'MacroCallParsingMode.BLOCK'>> {
  elementType = MacroCall
  hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
  name = "macro call"
}

// Parses macro calls in expr/pat/type context, which do not require a semicolon
ExprLikeMacroCall ::= <<parseMacroCall 'MacroCallParsingMode.EXPR'>> {
  elementType = MacroCall
  name = "macro call"
}

MacroArgument ::= <<any_braces MacroArgumentTT>> {
  elementTypeFactory = "org.rust.lang.core.psi.LazyElementsKt.factory"
  extraRoot = true
}
MacroArgumentTT ::= (<<any_braces MacroArgumentTT>> | MacroBodyIdent | MacroBodyQuoteIdent | <<unpairedToken>>)*
MacroBodyIdent ::= identifier {
  implements = "org.rust.lang.core.psi.ext.RsReferenceElementBase"
  mixin = "org.rust.lang.core.psi.ext.RsMacroBodyIdentMixin"
}
MacroBodyQuoteIdent ::= QUOTE_IDENTIFIER {
  implements = "org.rust.lang.core.psi.ext.RsReferenceElementBase"
  mixin = "org.rust.lang.core.psi.ext.RsMacroBodyQuoteIdentMixin"
}

CompactTT ::= (<<any_braces CompactTT>> | <<unpairedToken>>)*

// Used only manually in (external) macro matching code
//noinspection BnfUnusedRule
TT ::= <<any_braces TT*>> | <<unpairedToken>>

// *Special* macro argument types. How to add new one:
// 1. Write here a grammar for the argument
// 2. Add it to `MacroCall` rule
// 3. Add it to `RustParserUtil.SPECIAL_MACRO_PARSERS` map
// 4. Add it to `MACRO_ARGUMENT_TYPES` set in `RsMacroCall.kt`
// If it is an expression, also:
// 1. add it to `RustParserUtil.SPECIAL_EXPR_MACROS` set
// 2. implement type inference logic in `RsTypeInferenceWalker.inferMacroExprType0`

// Expression node is optional to avoid parsing error when expr is not typed yet (like `dbg!()`)
//noinspection BnfUnusedRule
ExprMacroArgument ::= <<any_braces [ AnyExpr ','? ]>>
// https://doc.rust-lang.org/std/fmt/
//noinspection BnfUnusedRule
FormatMacroArgument ::= <<any_braces [ <<comma_separated_list FormatMacroArg>> ] >>
//noinspection BnfUnusedRule
FormatMacroArg ::= [ identifier '=' ] AnyExpr
//noinspection BnfUnusedRule
AssertMacroArgument ::= <<any_braces (AnyExpr [ ',' <<comma_separated_list FormatMacroArg>> ])>>
//noinspection BnfUnusedRule
VecMacroArgument ::= <<any_braces ArrayInitializer >>
//noinspection BnfUnusedRule
LogMacroArgument ::=
  <<any_braces (('target' ':' Expr ','?)? (<<comma_separated_list FormatMacroArg>>)?)>>
//noinspection BnfUnusedRule
IncludeMacroArgument ::= <<any_braces (AnyExpr ','?)>> {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
//noinspection BnfUnusedRule
ConcatMacroArgument ::= <<any_braces <<comma_separated_list AnyExpr>>?>> {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
//noinspection BnfUnusedRule
EnvMacroArgument ::= <<any_braces <<comma_separated_list AnyExpr>>? >> {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private meta any_braces ::= <<parseAnyBraces <<param>>>> | never '(' '{' '[' ']' '}' ')' <<param>>

// Macro wrappers
MacroExpr ::= ExprLikeMacroCall {
 elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
PatMacro ::= ExprLikeMacroCall

///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Block ::= '{' InnerAttr* (Item | Stmt)* Expr? '}' {
  pin = 1
  implements = "org.rust.lang.core.psi.ext.RsItemsOwner"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

SimpleBlock ::= '{' BlockElement* '}' {
  pin = 1
  elementType = Block
}

InnerAttrsAndBlock ::= '{' InnerAttr* BlockElement* '}' {
  pin = 1
  elementType = Block
}

private ShallowBlock ::= <<parseCodeBlockLazy>>

private BlockElement ::= !'}' (BlockElementMacro | BlockElementMacroCall | ExprStmtOrLastExpr | Stmt | Item) {
  pin = 1
  recoverWhile = BlockElement_recover
}
private BlockElement_recover ::= !('}' | Item_first | Expr_first | let | ';')

Stmt ::= LetDecl | EmptyStmt | never ';' {
  implements = "org.rust.lang.core.macros.RsExpandedElement"
  mixin = "org.rust.lang.core.psi.ext.RsStmtMixin"
}

ExprStmtOrLastExpr ::= StmtModeExpr (&'}' | ExprStmtUpper) {
  elementType = Expr
}

upper ExprStmtUpper ::= () (';' | <<isBlock>>) { pin = 1 elementType = ExprStmt }

fake ExprStmt ::= AnyExpr ';'? { extends = Stmt }

LetDecl ::= OuterAttr* let Pat TypeAscription? [ '=' AnyExpr ] ';' {
  extends = Stmt
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner" ]
  pin = "let"
}

EmptyStmt ::= ';' { extends = Stmt }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Utils
///////////////////////////////////////////////////////////////////////////////////////////////////

// Keep in sync with `collapsedTokenType`
private gtgteq ::= <<gtgteqImpl>>
private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlteq ::= <<ltlteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>

private never ::= !()

// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( ',' <<param>> )* ','?
private meta list_element ::= !'>' <<param>> (',' | &'>') { pin = 2 }

// Use as an `elementType` for always upped rules like `Rule ::= FOO BAR ( upper1 | upper2 ) `
// (without an `elementType` upper rules won't work, GK can change element type of the frame
// only if it already has some type)
// https://github.com/JetBrains/Grammar-Kit/blob/d716ade658/src/org/intellij/grammar/parser/GeneratedParserUtilBase.java#L656
fake ToBeUpped ::=
